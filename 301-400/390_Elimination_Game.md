# 390. Elimination Game(M)

[390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)

## 题目描述(中等)

给定一个从1 到 n 排序的整数列表。  
首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。  
第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。  
我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。  
返回长度为 n 的列表中，最后剩下的数字。  

示例：
```
输入:
n = 9,
1 2 3 4 5 6 7 8 9
2 4 6 8
2 6
6
```

## 思路

- 模拟删除过程
- 

## 解决方法

### 模拟删除过程

flag:正向标志

```java
    public int lastRemaining0(int n) {
        if (n <= 0) {
            return 0;
        }
        List<Integer> list = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            list.add(i);
        }
        boolean flag = true;
        while (list.size() > 1) {
            if (list.size() % 2 == 1 || flag) {
                for (int i = 0; i < list.size(); i++) {
                    list.remove(i);
                }
            } else {
                for (int i = 1; i < list.size(); i++) {
                    list.remove(i);
                }
            }
            flag = !flag;
        }
        return list.get(0);
    }
```

### 规律

找到第一个数的变化规律
- 左起，第一个数都要被删除，即删除后数列的第一个数是删除前数列的第二个数；
- 右起，第一个数是否会被删除完全依赖于数列的长度，若长度为偶数，删除后数列的第一个数不变，否则，删除后的第一个数是原数列的第二个数。
- 综上，当左起或者右起长度为奇数时，删除后数列的第一个数是原数列的第二个数，其他情况，删除后数列的第一个数不变


新数列的公差是原数列的2倍

第一个数的变化规律仅与数列的第一项和第二项有关

flag:正向标志

```java
    public int lastRemaining1(int n) {
        if (n <= 0) {
            return 0;
        }
        int first = 1;
        int delta = 1;
        boolean flag = true;
        while (n != 1) {
            if ((n & 1) == 1 || flag) {
                first += delta;
            }
            n >>= 1;
            delta <<= 1;
            flag = !flag;
        }
        return first;
    }

```

### 递归

```
输入输出示例：
1   -> 1        1   ->  1       1   ->  1
3   -> 2        2   ->  2       5   ->  2
6   -> 4        4   ->  2       10  ->  8
12  -> 6        8   ->  6       20  ->  6
24  -> 12       16  ->  6       40  ->  30
48  -> 22       32  ->  22      80  ->  22
96  -> 54       64  ->  22      160 ->  118
182 -> 86       128 ->  86      320 ->  86

左边的是输入，箭头右边是输出。
如果输入是 a 而输出是 b ，那么输入是 2a 时的输出就是 2*(a-b+1)
```

1 2 3 4 5 6 7 8 9 10，一轮下来就剩下 2 4 6 8 10 一共五个数，正好是一半。  
而 2 4 6 8 10， 其实可以对应到 5 4 3 2 1。在 5 的解中输出 2 , 对应到 8 的位置， 所以 10 输出 8。

如果说 1 2 3 4 5 中 2 在 2 号位，在 5 4 3 2 1 中就是 5 - (2 - 1) = 4 号位。  
然后得到值后对应到两倍上的输入，于是就是 2*(a - b + 1)。

输入为偶数 e 时，其输出的结果和 e+1 相同。也就是说如果输入是奇数，只要找比它小1的偶数当作输入就好


```java
    //f(n) = 2*(n/2+1-f(n/2));  n为偶数
    //f(n) = f(n-1);            n为奇数
    public int lastRemaining(int n) {
        return n == 1 ? 1 : 2 * (n / 2 - lastRemaining(n / 2) + 1);
    }
```